b'ABSTRACT  \nIn this paper we present an impr oved redesign of the R*-tree that is\nentirely suitable for running within a DBMS. Most importantly, an\ninsertion is guaranteed to be restricted to a single path because\nre-insertion could be abandoned. We re-engineered both, subtree\nchoice and split algorithm, to be more robust against specific data\ndistributions and insert ion orders, as well as  peculiarities often\nfound in real multidimensional data sets. This comes along with a\nsubstantial reduction in CPU-time. \nOur experimental setup covers a wi de range of different artificial\nand real data sets. The experime ntal comparison shows that the\nsearch performance of our revised R* -tree is superior to that of its\nthree most important competitors. In comparison to its predecessor,\nthe original R*-tree, the creation of a tree is substantially faster,\nwhile the I/O cost required for processing queries is improved by\nmore than 30% on average for two-  and three-dimensional data. For\nhigher dimensional data, particularly for real data sets, much larger\nimprovements are achieved.\nCategories and Subject Descriptors\nH.2.8 [ Database Applications ]: Spatial database s and GIS; H.2.2\n[Physical Design ]: Access methods; H.3.1 [ Content Analysis and\nIndexing ]: Indexing methods\nGeneral Terms\nAlgorithms, Design, Experi mentation, Performance\nKeywords\nIndex structures, Revise d R*-tree, RR*-tree, R-tree, Hilbert-R-tree,\nMulti-dimensiona l data, Split, ChooseSubtree, Performance com-\nparison1. INTRODUCTION\nR-trees [15] are among the most popular multidimensional access\nmethods suitable for indexing two-dimensional spatial data and\nmedium-dimensional point data. Due to their conceptual simplicity\n(and excellent performance), R-tree s have been successfully imple-\nmented within commercial systems like IBM Informix [18], Oracle[22, 21], Sun MySQL [25], and open source database systems likePostgreSQL [27], and various research prototypes including Shore\n[9] and GIST [16]. Moreover, R-tr ee implementations are available\nin geographic information sy stems like MapInfo [32].\nDuring the last two decades different proposals for R-trees haveemerged, mainly differing in the split algorithm and the traversal\nalgorithm for the insertion of  new objects (c ommonly called\nChooseSubtree ). In different experiment al studies, see for example\n[17], the R*-tree [6] has been show n to be the most efficient struc-\nture regarding query performance. Therefore, the R*-tree has\nserved as a guideline for many R-tree implementations and has\ninfluenced the design of other access methods, es pecially those\nsuitable for indexing high-d imensional point  data [2].\nHowever, applying the algorithms of the R*-tree completely was\ninterfered by some deficiencies. Firs t, re-insertion of entries, which\nis considered to be one of the essential contributions to improve\nquery performance, is a cumberso me concept in DBMS. Its disad-\nvantage is that it prevents the us age of efficient algorithms for con-\ncurrency control [19, 11]. Seco ndly, overlap optimization during\nChooseSubtree, probably the mo st important optimization to\nenhance query performance, is only  performed rudimentarily. It is\nrestricted to the lowest direct ory level and limited by a constant\nparameter to keep CPU cost acce ptable. This parameter however is\ndifficult to set in view of the changing demands by different data\nsets and varying dime nsionalities. Another deficiency of the\nR*-tree is that the scoring functi on of the split does not take into\naccount the balance of the split pages. Though the imbalance of a\nsplit is limited by a parameter m, the degree of imbalance of inser-\ntions does not influence the split of a page. This deficiency is not\nunique to the R*-tree, but can be  observed for all members of the\nR-tree family. Another problem refe rs to the fact that R-trees are\nnot really well designed for high-dimensional data. As degenerated\nbounding boxes with zero volume are not uncommon for high\ndimensional data, the commonly us ed volume-based strategies for\nsplitting are becoming ineffective.\nIn this paper, we present an update  of the algorithms of the R*-tree.\nWhile basic design principles did not  change, e.g. the nature of the\nsplit and important optimization criteria of ChooseSubtree, the idea\nof re-insertion was abandoned as it  prevents the applicability in a\nDBMS. We redesigned th e algorithm ChooseSubtre e so that irrele-Permission to make digital or hard copi es of all or part of this work for\npersonal or classroom use is granted without fee provided that copies are\nnot made or distributed for profit or commercial advantage and that copies\nbear this notice and the full citation on  the first page. To copy otherwise,\nor republish, to post on servers or to  redistribute to lists, requires prior\nspecific permission and/or a fee.\nSIGMOD\xe2\x80\x9909, June 29\xe2\x80\x93July 2, 2009, Providence, RI, USA.\nCopyright 2009 ACM  978-1-60558-551-2/09/06...$5.00.A Revised R*-tree in Comparison with \nRelated Index Structures\nNorbert Beckmann\nDepartment of Computer Science\nUniversity of Bremen\nD-28359 Bremen\nGermany\nnb@informatik.uni-bremen.deBernhard Seeger\nDepartment of Computer Science\nUniversity of Marburg\nD-35032 Marburg\nGermany\nseeger@informatik.uni-marburg.de\n799\n'
b'vant entries, which are not able to host the new object, are pruned.\nThis reduces CPU time considerably, so that an effective overlap\noptimization can be a pplied now on all directory levels. Our split\nalgorithm is not limited to optim izing well-known criteria (over-\nlap, volume, perimeter),  but also takes into account the balance of\nthe split. In general we prefer splits where half of the data is moved\ninto a new page. However, balanc ed splits are not our first choice\nwhen the data is inserted in non -random order. By keeping track of\nthe modification of a node\xe2\x80\x99s minimum bounding box (MBB), we\nare able to anticipate where data is likely to be inserted in the nearfuture. This leads to a new highly adaptive split algorithm. More-\nover, both, ChooseSubtree and sp lit, identify when volume-based\noptimization is not effe ctive anymore and switch in such situations\nto perimeter-based strategies.\nIn general, the Revised R*-tree ( RR*-tree) should meet the follow-\ning performance requirement. The query cost should be noticeable\nbetter than that of the original R* -tree for a large ra nge of data files\nand arbitrary data dimensionality. Cost generally refers to the num-\nber of I/Os, but the RR*-tree should also provide acceptable\nCPU-performance when data is  organized in main memory.\nThe performance of the RR*-tree is shown in different sets of\nexperiments with data of differ ent dimensionality.  We considered\nartificial data sets as well as data sets obtained from real applica-\ntion scenarios. Our experimental  comparison includes Guttman\xe2\x80\x99s\nquadratic R-tree [15], the original R*-tree [6], the Hilbert-R-tree\n[19], and the RR*-tree. To the be st of the authors\xe2\x80\x99 knowledge, we\nare not aware of such a comprehensive performance comparisonfor R-trees. Therefore, a major c ontribution of the paper is the def-\ninition of our experimental setup that can serve as a test bed in\nfuture. \nThe paper is structured in the following way. Section 2 introduces\nour notation and gives a brief review of previous work. In\nSection 3 we present the details of our new algorithm for choosing\na subtree. In Section 4 our new sp lit algorithm is presented. Sec-\ntion 5 consists of a precise descri ption of our experiments as well\nas a discussion of our results. \n2. PRELIMINARIES\nAn R-tree [15] is a height-balan ced tree, designed for organizing a\nset of dim-dimensional rectilinear rect angles in a dynamic setting.\nThe primary goal of the R-tree is to assign rectangles to leaves in a\nway that spatial proximit y is preserved within a leaf. Internal nodes\ncontain entries which consist of a reference to a subtree T and the\nMBB of the rectangles in T. The entries of leaves consist of a refer-\nence to an object and the MBB of  that object. A node of an R-tree\ncorresponds to a page of fixed si ze. In the rest of the paper, M\ndenotes the capaci ty of a node and m is the minimum occupation of\na node, m \xef\x82\xa3 \xef\x83\xa9M/2\xef\x83\xb9.\nAn insertion of a new rectangle into an R-tree starts at its root. A\nroutine ChooseSubtree  is called to determine a child node. Choose-\nSubtree is iteratively called until a leaf is found. The rectangle is\ninserted into the leaf and modifications of the leaf\xe2\x80\x99s MBB are\npropagated upwards along the inse rtion path. If the leaf already\ncontains M objects, a routine termed Split is called. Split distrib-\nutes the objects into two groups ; the one remains in the original\nleaf, whereas the other is stored in a new leaf. Thereafter the origi-nal index entry is updated, and a new entry referring to the new\nleaf is inserted into the parent  node, which may have to be split\nanalogously.\n2.1  Related Work\nThere are different kinds of R-trees which mainly differ according\nto their splitting strategy, see [24] for a comprehensive survey on\nR-trees. Originally Guttman propos ed two greedy strategies [15],\nthe one with linear run time and th e other with quadratic. Both rely\non first picking two seeds from the entries in the node. The remain-\ning entries are then distributed among the seeds. Experiments have\nrevealed that the algorithm with quadratic run time results in\nR-trees with better search perfo rmance. Many DBMSs like Postgr-\neSQL make use of the quadratic gr eedy strategy. The R*-tree [6] is\nbased on a quite different approach, where a split of a node is opti-mized with respect to different criteria of the MBBs of the result-\ning nodes. This approach has been  justified later by a static cost\nmodel, introduced in [28] and [13], where the volume of the boxes\nand particularly their perimeter have been shown to be the domi-\nnant parameters for the I/O cost of queries. Anothe r beneficial idea\nof the R*-tree is that splits ar e deferred by re-inserting the objects\nfarthest away from the center of the MBB. This improves query\nperformance and increase s storage utilization. \nThe Hilbert-R-tree [19] is anot her kind of R-tree which actually\nbehaves like a B+-tree when objects  are inserted. The basic idea is\nto insert rectangles into the tree, using the one-dimensional Hil-\nbert-value of the center of the rect angles. In addition to this routing\ninformation required for insertions , the MBB of a subtree is stored\nin the corresponding index entry. These rectangles are used forquery processing only. This actually  leads to a structure with excel-\nlent insertion performance, but our  experimental results generally\nshow, that the search quality of the tree suffers from theone-dimensional insertion strate gy. Additionally, the structure\nneeds a pre-defined data space. In  fact, a main advantage of the\noriginal R-tree and most of its vari ants is that there is no need for a\npre-defined data space. Unlike structures relying on transformationand one dimensional encoding, like  the Hilbert-R-tree, R-trees do\nnot require global reorga nization when new data has to be inserted\noutside planned boundaries. \nThe problem of splitting a group of rectangles into two has been\naddressed in [4], where an algorithm with run time O( M\ndim) is pre-\nsented for computing an optimal sp lit. Quite a simila r approach has\nbeen presented in [14]. Experime nts however showed, that an opti-\nmal splitting routine only margin ally improves the overall perfor-\nmance of the R-tree in comparison to other strategies (since\nsubsequent insertions will compensate the advantage). A substan-\ntial performance impr ovement can be achiev ed by global optimiza-\ntion techniques [29, 14]. Unfort unately, these techniques also\nrequire a substantial am ount of reorganization that is only accept-\nable in off-line mode. Since effi cient concurrency control is a\nmajor concern for index structures too, it is ques tionable whether\nthese techniques will be integrated into the implementations of\nR-trees that are available in commercial DBMS.\nBulk-loading of R-trees has also re ceived research attention. Dif-\nferent techniques [7, 1] have been proposed that substantially\nreduce the cost of the naive seque ntial insertion strategy where one\ntuple is inserted at a time. The bulk-loading method of [1] gener-\n800'
