b'Elliptic Indexing of Multidimensional Databases\nOndrej Danko1Tom\xc2\xb4 a\xcb\x87 s Skopal2\n1Comenius University in Bratislava, FMUK, Department of Information Systems\nOdboj\xc2\xb4 arov 10, 820 05 Bratislava, Slovak Republic\nEmail: ondrej.danko@fm.uniba.sk\n2Charles University in Prague, FMP, Department of Software Engineering\nMalostransk\xc2\xb4 e n\xc2\xb4 am. 25, 118 00 Prague, Czech Republic\nEmail: skopal@ksi.mff.cuni.cz\nAbstract\nIn this work an R-tree variant, which uses minimum\nvolume covering ellipsoids instead of usual minimum\nbounding rectangles, is presented. The most signi\xef\xac\x81-\ncant aspects, which determine R-tree index structure\nperformance, is an amount of dead space coverage and\noverlaps among the covering regions. Intuitively, el-\nlipsoid as a quadratic surface should cover data more\ntightly, leading to less dead space coverage and less\noverlaps. Based on studies of many available R-tree\nvariants (especially SR-tree), the eR-tree (ellipsoid\nR-tree) with ellipsoidal regions is proposed. The fo-\ncus is put on the algorithm of ellipsoids construction\nas it signi\xef\xac\x81cantly a\xef\xac\x80ects indexing speed and querying\nperformance. At the end, the eR-tree undergoes ex-\nperiments with both synthetic and real datasets. It\nproves its superiority especially on clustered sparse\ndatasets.\n1 Introduction\nIn the last decades, the demand for e\xef\xac\x83cient search-\ning in large multimedia databases has begun emerg-\ning much more often than anytime before. Espe-\ncially the applications from areas like medicine, geog-\nraphy or CAD experienced an absence of techniques\nwhich would enable them to e\xef\xac\x83ciently search in pro-\ntein databases, geographical maps or CAD datasets.\nBecause the nature of geographical or medicine data\ndi\xef\xac\x80ers, a custom solution would be always required\nto provide e\xef\xac\x83cient retrieval. To solve this problem,\nsimple, yet powerful idea is applied \xe2\x80\x93 feature transfor-\nmation. Each object of a dataset is transformed into a\ntuple ofn-dimensional space representing that object\n(based on certain transformation rules). Afterwards,\na multidimensional indexing technique is employed to\nenable fast retrieval. The most obvious query type in\nmultidimensional indexing is window query (or range\nquery). A window query simply speci\xef\xac\x81es some por-\ntion of the n-dimensional space, a window (set of in-\ntervals on all dimensions), and returns all dataset tu-\nples inside.\n2 Related Work\nTo e\xef\xac\x83ciently search for tuples inside a query window,\nwe have to employ a spatial access method (SAM,\nor called a multidimensional index). In this section\nCopyright c\xe2\x83\x9d2009, Australian Computer Society, Inc. This pa-\nper appeared at the 20th Australasian Database Conference\n(ADC 2009), Wellington, New Zealand, January 2009. Con-\nferences in Research and Practice in Information Technology\n(CRPIT), Vol. 92, Athman Bouguettaya and Xuemin Lin, Ed.\nReproduction for academic, not-for pro\xef\xac\x81t purposes permitted\nprovided this text is included.\nFigure 1: R-tree index structure.\nwe give an overview of the most successful SAMs, all\nbased on R-tree.\n2.1 R-tree\nThe R-tree (Guttman 1984) is a height-balanced mul-\ntidimensional index structure similar to B-tree. The\nbasic idea behind the R-tree is to hierarchically par-\ntition the search space into nested regions. The space\npartitioning is neither complete nor disjoint, while the\nnested hierarchies are formed as paths from the root\nnode to the leaf nodes. The root node region en-\ncloses regions of all its child nodes. The R-tree con-\nsists of inner and leaf nodes. A leaf node holds the\ndata tuples and consists of entries \xe2\x9f\xa8I,data\xe2\x9f\xa9, where\nIrepresents a minimum bounding rectangle (MBR)\nofdata. Similarly, an inner node consist of entries\n\xe2\x9f\xa8I,childpointer\xe2\x9f\xa9whereIis MBR of all entries con-\ntained in node referenced by childpointer , see Fig-\nure 1. Searching in R-tree index structure means\ntraversing those paths of the tree that intersect with\nthe search region (query window in our case).\n2.2 Other SAM\nAn extensive study of the original Guttman\xe2\x80\x99s R-tree\non di\xef\xac\x80erent data distributions led to proposal of some\noptimizations, as:\n\xe2\x80\xa2minimization of leaf level node region overlaps\nProc. 20th Australasian Database Conference (ADC 2009), Wellington, New Zealand\n85'
b'\xe2\x80\xa2minimization of leaf level regions surface\n\xe2\x80\xa2minimization of volume of inner nodes\n\xe2\x80\xa2maximization of storage utilization\n2.2.1 R*-tree\nThe R*-tree (Beckmann et al. 1990) introduces\nforced reinsertions , because R-tree-based structures\nare highly sensitive to the order in which are tuples\ninserted. When a leaf node becomes overfull, some\nportion of its member tuples which are most distant\nfrom the center of the node\xe2\x80\x99s MBR are deleted from\nindex and reinserted again. This improvement pushed\nthe storage utilization to 71% -76%. The R*-tree also\nprefers squared MBRs over rectangular.\n2.2.2 R+-tree\nThe key idea behind the R+-tree (Sellis et al. 1987) is\nan overlap-free splitting in the tree directory (the in-\nner nodes). Generally, there is no guarantee that such\nsplitting exists. In case there exists no overlap-free\nsplitting, the R+-tree introduces a forced splitting .\nWhen considering the example in Figure 1, to get\nrid of overlap between the A and B regions, we neces-\nsarily need to split the region B1. Of course, in some\nsituations forced splits need to be propagated until we\nreach leaf nodes, whereas the number of forced splits\ncan exponentially increase till we reach them. As a\nside e\xef\xac\x80ect of forced splits, unlike regular R-tree, the\nR+-tree also cannot guarantee 50% space utilization.\nOn the other hand, the authors of R+-tree claim their\nmodi\xef\xac\x81cation requires 50% less page accessess (on av-\nerage) to process a query, compared to the R-tree.\n2.2.3 SS-tree\nThe SS-tree (White & Jain. 1996) was introduced to\nsupport similarity searches (meaning nearest neighbor\nqueries) in higher dimensions (thus Similarity Search-\ntree). The SS-tree uses spheres instead of MBRs as\npage regions. When comparing properties of MBRs\nwith spheres, it should be said that:\n\xe2\x80\xa2Bounding spheres tend to produce regions bigger\ninvolume than MBRs.\n\xe2\x80\xa2Bounding spheres tend to produce regions of\nsmaller diameter than MBRs.\nWhen using spheres, the \xef\xac\x81rst mentioned property de-\ncreases the performance of window queries, while the\nsecond one favors the nearest neighbor queries. An-\nother advantage of spheres is that they require less\nspace to be stored than MBRs. For MBR we need\nto store two n-dimensional vectors, while for sphere\nit is enough to store one n-dimensional center and a\none-dimensional diameter. This allows higher fanout\nof nodes, thus it eventually decreases the tree height.\nFor performance reasons the spheres of SS-tree are not\nminimum volume spheres, but use centroids as their\ncenters. Thus, the center of the sphere is computed\nas the average in each dimension of the data tuples\nbeing bounded. The diameter is then calculated so\nthat it covers all tuples.\nThe SS-tree uses forced reinserting when an over-\n\xef\xac\x82ow is encountered; 30% of tuples with highest dis-\ntance from the center of sphere are reinserted. While\nthe storage utilization of R*-tree is just 70-75%, the\nSS-tree reaches 85% on average. The splitting is\nbased on variance. First, the dimension with high-\nest variance is choosen. Then a split plane orthog-\nonal to that dimension is found, so that the sum of\nvariances in both, the new node and the old node,is minimized. The authors of SS-tree claim the in-\nsertion uses signi\xef\xac\x81cantly less CPU time, compared to\nR*-tree (5-10x less). This is mainly because of sim-\nplistic insertion and linear split algorithm, compared\nto quadratic split algorithm of R*-tree. When query-\ning, the SS-tree outperforms the R*-tree by a factor\nof two (approximately).\n2.2.4 SR-tree\nThe SR-tree (Katayama & Satoh 1997) is merely a\ncombination of SS-tree and R*-tree. The authors pre-\nsented an extensive comparison of MBRs and spheres\nproperties. They de\xef\xac\x81ned a region in SR-tree as an\nintersection of MBR and sphere, gaining both advan-\ntages \xe2\x80\x93 a small volume of the MBR and a small diame-\nter of the sphere. This extension should bring reason-\nable query performance for both window and nearest\nneighbor queries. The insertion and split algorithms\nare taken from the SS-tree and they are controlled\nsolely by spheres. The SR-tree slightly outperforms\nboth SS-tree and R*-tree. As the most signi\xef\xac\x81cant in-\ne\xef\xac\x83ciency of this approach, the authors discuss stor-\nage requirements of SR-tree region, which are 1.5\xc3\x97\nlarger than that of R*-tree and 3 \xc3\x97larger than that\nof SS-tree.\n2.2.5 X-tree\nThe X-tree (Berchtold et al. 1996) provides overlap-\nfree split whenever it is possible, that is, just splits\nthat do not lead to degeneration of the tree are al-\nlowed. Otherwise, the X-tree creates variable-sized\ndirectory nodes, so-called supernodes, to keep the\nhierarchy spatially compact. Since the supernodes\ncan be quite large (which leads to partial sequential\nsearch), the X-tree could be seen as a hybrid of a\nlinear array-like and a hierarchical R-tree-like direc-\ntory. The main advantage is X-tree\xe2\x80\x99s performance\nwhen querying high-dimensional data, where it out-\nperforms the R*-tree by up to two orders of magni-\ntude.\n3 The eR-tree\nAs many studies (Beckmann et al. 1990, Katayama &\nSatoh 1997) indicate, the performance of the R-tree-\nbased structures is mostly determined by the amount\nof region overlaps and dead space coverage. Most of\nthe R-tree variants try to handle this problem by re-\nvisiting the splitting algorithms (e.g., the overlap-free\none (Sellis et al. 1987)) or introducing concepts like\nforced reinserts, which \xef\xac\x81ght against the dynamic be-\nhavior of R-tree indexing. Our idea is to substitute\nthe usually employed MBRs with arbitrarily rotated\nellipsoids. Intuitively, ellipsoid, as a quadratic sur-\nface, could cover the data more tightly, leading to re-\ngions smaller in volume (less dead space coverage) and\npossibly less overlaps (i.e., smaller regions naturally\nproduce less overlaps). To grasp our \xe2\x80\x9cmotivation\xe2\x80\x9d,\nconsider Figure 2a \xe2\x80\x93 10 randomly generated tuples\nare covered by an ellipsoid and an MBR. The volume\nof the ellipsoid is 0.074 and the volume of the MBR is\n0.181 so the ellipsoid is 2.4\xc3\x97 smaller in volume than\nthe MBR.\n3.1 Index Structure\nThe structure of eR-tree is based on the origi-\nnal Guttman\xe2\x80\x99s R-tree (Guttman 1984). The most\nstraightforward application of ellipsoids in R-tree\nwould substitute all MBRs with ellipsoids. However,\nour preliminary tests revealed the following facts:\nCRPIT Volume 92 - Database Technologies 2009\n86'
