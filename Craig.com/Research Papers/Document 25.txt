b'NIR-Tree: A Non-Intersecting R-Tree\nKyle Langendoen, Brad Glasbergen, Khuzaima Daudjee\n{kjlangen,bjglasbe,kdaudjee}@uwaterloo.ca\nCheriton School of Computer Science\nUniversity of Waterloo\nABSTRACT\nIndexes for multidimensional data based on the R-Tree are popu-\nlarly used by databases for a wide range of applications. Such index\ntrees support point and range queries but are costly to construct\nover datasets of millions of points. We present the Non-Intersecting\nR-Tree (NIR-Tree), a novel insert-efficient, in-memory, multidimen-\nsional index that uses bounding polygons to provide efficient point\nand range query performance while indexing data at least an or-\nder of magnitude faster. The NIR-Tree leverages non-intersecting\nbounding polygons to reduce the number of nodes accessed during\nqueries, compared to existing R-family indexes. Our experiments\ndemonstrate that inserting into a NIR-Tree is 27\xc3\x97faster than the\nubiquitous R*-Tree, with point queries completing 2\xc3\x97faster and\nrange queries executing just as quickly.\nCCS CONCEPTS\n\xe2\x80\xa2Information systems \xe2\x86\x92Multidimensional range search .\nKEYWORDS\nMultidimensional indexing, Tree, Bounding polygon\nACM Reference Format:\nKyle Langendoen, Brad Glasbergen, Khuzaima Daudjee. 2021. NIR-Tree: A\nNon-Intersecting R-Tree. In 33rd International Conference on Scientific and\nStatistical Database Management (SSDBM 2021), July 6\xe2\x80\x937, 2021, Tampa, FL,\nUSA. ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3468791.\n3468818\n1 INTRODUCTION\nMultidimensional indexes are an important part of modern databases\n[10,12,20]. Correlated data, such as points in space or the RGB\nvalues of a pixel, can be stored and retrieved together in multidimen-\nsional indexes. These indexes need to support efficient querying\nand retrieval of data for many popular application domains, such as\ninfectious disease tracking, continental road networks, video game\nstates, and scientific simulations of entire galaxies. The volume and\nvariety of such multidimensional data demand indexes that can\ndeliver high performance through low latency querying of data.\nSolutions to indexing multidimensional data [ 3,14,22] are based\nlargely on the conceptual structure that originates from the R-Tree\nPermission to make digital or hard copies of all or part of this work for personal or\nclassroom use is granted without fee provided that copies are not made or distributed\nfor profit or commercial advantage and that copies bear this notice and the full citation\non the first page. Copyrights for components of this work owned by others than ACM\nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,\nto post on servers or to redistribute to lists, requires prior specific permission and/or a\nfee. Request permissions from permissions@acm.org.\nSSDBM 2021, July 6\xe2\x80\x937, 2021, Tampa, FL, USA\n\xc2\xa92021 Association for Computing Machinery.\nACM ISBN 978-1-4503-8413-1/21/07. . . $15.00\nhttps://doi.org/10.1145/3468791.3468818\nFigure 1: An R-Tree exhibiting scatter during search.\n[11]. R-Trees recursively group multidimensional data into bound-\ning rectangles that represent an approximation of the data group\xe2\x80\x99s\nlocal region of space. When executing search queries, bounding rect-\nangles are consulted to direct the search into continually smaller,\nmore specific rectangular regions that meet the search criteria.\nWhen data groups are poorly represented by large or intersecting\nbounding rectangles, search is slowed by accessing regions whose\ndata does not meet the search criteria.\nTo illustrate, consider Figure 1 depicting an R-Tree with nodes\nand associated bounding rectangles shown in the same colour. R-\nTrees require parent bounding rectangles to enclose their children\xe2\x80\x99s\nbounding rectangles, and so R\xe2\x80\x99s black bounding rectangle encloses\nchildren AandBwith blue and yellow bounding rectangles respec-\ntively. The search for the black point in Figure 1, indicated by the\ndashed red line, is slowed by scattering into logical nodes AandF.\nThis search spuriously accesses AandFwhich do notcontain the\ndesired point because their associated bounding rectangles unde-\nsirably enclose the point. Bounding rectangle pairs A,BandE,F\ncreate scatter and thus slow search with their intersection .\nFigure 2: NIR-Tree exhibiting no scatter during search.\nA desirable, efficient multidimensional index would support\nsearch by minimizing intersection between bounding rectangles. As\na running example, consider the same point from Figure 1 indexed\nby the reconfigured geometry in Figure 2. This improved R-Tree\ndesign, which we call the NIR-Tree , removes the intersection area\nbetween bounding polygon pairs A,BandE,F. By doing so, search\n157\n'
b'SSDBM 2021, July 6\xe2\x80\x937, 2021, Tampa, FL, USA Kyle Langendoen, Brad Glasbergen, Khuzaima Daudjee\nfor the same black data point no longer scatters to nodes Aand\nF. This 40%reduction in accessed nodes, again highlighted by a\ndashed red path in Figure 2, translates into a faster search.\nPrior proposals improved ways to organize bounding rectangles\n[3,14,22] while other approaches [ 13,15] abandoned rectangles\nentirely in favour of more complex geometric objects. Although\nthese approaches reduce intersection area they, unlike our proposed\nNIR-Tree, cannot eliminate it entirely. Proposals which use arbitrar-\nily shaped bounding objects [ 13,15] suffer from slow, complicated\ngeometric tests to determine if a point is enclosed by a bounding\nobject.\nIn this paper, we present the NIR-Tree, a new, entirely in-memory\ntree that adaptively replaces bounding rectangles with bounding\npolygons. The NIR-Tree guarantees zero-area intersection between\nbounding polygons which accelerates point queries by reducing the\nnumber of nodes accessed compared to existing R-family indexes.\nOur experiments demonstrate that inserting into a NIR-Tree is an\norder of magnitude faster than the ubiquitous R*-Tree, with point\nqueries completing in half the time and range queries executing\njust as quickly.\nConcretely, our contributions to multidimensional indexing are:\n(1)The design and implementation of the NIR-Tree, a novel in-\nmemory technique to create axis-aligned bounding polygons\nfrom bounding rectangles.\n(2)A zero-area intersection guarantee among bounding poly-\ngons in the NIR-Tree, including an analysis and proof of this\nguarantee.\n(3)Extensive evaluation on both real and synthetic datasets,\ndemonstrating that the NIR-Tree is 27.8\xc3\x97faster to construct,\n2.2\xc3\x97faster to point query, and up to 8%faster to range query\nthan the R*-Tree.\nSection 2 discusses how bounding polygons can eliminate inter-\nsection area, Section 3 presents the design of the NIR-Tree, Section\n4 analyzes the zero-area intersection guarantee, and Section 5 pro-\nvides an experimental evaluation of the NIR-Tree compared with\nprior approaches. Related work is covered in Section 6, and Section\n7 concludes our work. Without loss of generality, we discuss the\ntwo dimensional versions of trees throughout the paper (with the\nexception of Section 4) to simplify the presentation.\n2 BACKGROUND\nScatter, which degrades search performance in an R-Tree, is caused\nby positive intersection area. Insertions induce intersections when\nbounding rectangles are expanded to enclose a new point.\nWhen expansion is required, a bounding rectangle that will\ncontain the new point is selected for expansion based on a cost\nfunction called a metric . Bounding rectangles within the R-Tree\nare selected to minimize the amount of additional area required\nto enclose a new point. Figure 3a depicts the R-Tree\xe2\x80\x99s metric in\naction. A new black point must be enclosed either by the blue\nor the yellow rectangle. Since the yellow rectangle requires less\nadditional area than the blue rectangle to enclose the new point\nthe yellow rectangle is selected and expanded.\nBounding rectangle intersection is not limited to the R-Tree\xe2\x80\x99s\nmetric. For example, a simple alternative metric that selects bound-\ning rectangles based on minimum distance to the new point isdepicted in Figure 3b, yet intersection may still occur. For another\nexample, the R*-Tree [ 3] considers perimeter of the expanded bound-\ning rectangle (Figure 3a) and additional intersection area (Figure\n3c). However, all of these alternatives may cause intersection. The\nyellow rectangle in Figure 3 always minimizes the given metric in\neach case, yet its selection and expansion invariably causes posi-\ntive intersection area. Note that this happens even when the metric\noptimizes for intersection area directly .\nFigure 3: Expansion causing intersection in three examples.\nIn contrast with existing R-family trees, when the NIR-Tree\xe2\x80\x99s\nbounding rectangles cause intersection, they are replaced with\nbounding polygons that do not intersect. NIR-Tree bounding poly-\ngons are sets of rectangles that, when treated as a logical whole,\nform an axis-aligned polygon like the collection of blue {A1,A2}\nand green{F1,F2,F3}rectangles illustrated in Figure 2. By form-\ning bounding polygons from bounding rectangles during insert ,\nthe NIR-Tree achieves zero-area intersections between bounding\npolygons (Figure 2) where the R-Tree fails to do so.\n3 THE NIR-TREE\nIn this section, we outline the logical structure of the NIR-Tree\nand then describe in detail how the NIR-Tree creates, expands, and\nsplits bounding polygons (and associated nodes) during insert .\nAfterwards, the deletion operation remove is detailed, and the sec-\ntion concludes with an explanation of point and range search\noperations.\n3.1 Structure and Data Layout\nThe NIR-Tree is structured as a tree of nodes, each associated with\na bounding polygon. Nodes may be one of two types: routing or\nleaf. Routing nodes contain a set of branches, where branches are\na pointer to a child node child iand a bounding polygon Pirepre-\nsenting the geometric region of that child.\nDefinition 1. Arouting node is a tuple\n\xe2\x9f\xa8parent ,{\xe2\x9f\xa8child 0,P0\xe2\x9f\xa9, . . . ,\xe2\x9f\xa8child n,Pn\xe2\x9f\xa9}\xe2\x9f\xa9\nLeaf nodes contain a set of points, which are optionally asso-\nciated with some value. Both types of nodes contain a pointer to\ntheir parent to enable upwards tree traversal.\nDefinition 2. Aleaf node is a tuple\xe2\x9f\xa8parent ,{p0, . . . , pn}\xe2\x9f\xa9\n158'
