b' 1M+-tree: A New Dynamical Multidimensional Index for Metric Spaces \nXiangmin Zhou1, Guoren Wang1, Jeffrey Xu Yu2, Ge Yu1 \n1 Northeastern University, Shenyang, China \n{wanggr, yuge}@mail.neu.edu.cn \n2 The Chinese University of Hong Kong, Hong Kong, China \nyu@se.cuhk.edu.hk \n \nAbstract \nIn this paper, we propose a new metric index, called M+-tree, \nwhich is a tree dynamically organized for large datasets in \nmetric spaces. The proposed M+-tree takes full advantages of \nM-tree and MVP-tree, with a new concept called key dimension , \nwhich effectively reduces response time for similarity search. \nThe main idea behind the key dimension is to make the fanout of tree larger by partitioning a subspace further into two \nsubspaces, called twin-nodes. We can double the filtering \neffectiveness by utilizing the twin-nodes. In addition, for the \npurpose of ensuring high space utilization, we also conduct data \nreallocation between the twin nodes dynamically. Our \nexperiment shows that higher filtering efficiency can be \nobtained by using the key dimensions for r-neighbor search and \nk-NN (k-nearest \nneighbor ). We will report  our experimental \nresults in this paper.   \nKeywords : Multidimensional index, Metric space, Key \ndimension, Range search, k-NN search.  \n1 Introduction \nRecently, an incommensurable amount of audiovisual \ninformation becomes available in digital libraries, digital \narchives, personal and professional databases, the World Wide Web, and broadcast data streams. Besides, the data \nbulk continues to grow rapidly. A wide range of \napplications including image processing, geography system, medical applications and biomedicine, etc., \nhighly demand fast processing content-based similarity \nsearch in a very large databases.  \nIn order to respond such requests, there exist a large \nnumber of multidimensional indexes. As referred in the \nworks (N.Berkmann, H.-P. Krigel. R. Schneider, and B.Seeger.1990, N.Katayama and S.Satoh. 1997, \nD.A.White and R.Jain.1996, K.-I. Lin,H. V . Jagadish, and \nC. Faloutsos.1994), R-tree and its variants are widely used in geographical information systems. But they \ncannot be directly applicable to handle large datasets in \nmetric spaces.  Metric-based indices have been proposed \nfor a generic metric space, including VP-tree (J. K. \nUhlmann.1991), MVP-tree (T.Bozkaya, M.Ozsoyoglu. \n1997), M-tree(P.Zezula, P. Ciaccia, and F.Rabitti.1996, \nP.Ciaccia, M.Patella, P.Zezula.1997) and MB+tree (M. \nIshikawa, H. chen, K, Furuse, J.Xu Yu, N.Ohbo.2000). These index structures are different from the R\n*-tree and \nits other variants. They do not deal with the relative \npositions in a vector space, but rather handle the distances \n                                                        \n Copyright \xc2\xa9 2003, Australian Computer Society, Inc.  This paper appeared at the Fourteenth Australasian \nDatabase Conference (ADC2003), Adelaide, Australia.  \nConferences in Research and Practice in Information Technology, Vol. 17. Xiaofang  Zhou and Klaus-Dieter \nSchewe\n, Eds . Reproduction for academic, not-for profit \npurposes permitted provided this text is included. between objects. VP-tree (J. K. Uhlmann.1991) is \ndesigned with a hierarchical index structure for similarity \nsearch. It partitions a data set according to distances the objects have with respect to a vantage point. The median \nvalue of such distances is used as a separator to partition \nobjects into two balanced subsets. At the same time, the \nsame procedure is applied recursively. VP-tree is the first \none among the metric-based indices that utilizes the triangle inequality to filter and reduce the similarity \nsearch cost for multimedia in formation systems. However, \ndue to small fanout, VP-tree is very high thus a search operation needs a large number of distance calculations, \nwhich is time-consuming.\n \nMVP-tree extends the idea of VP-tree by using \nmultiple vantage points , and exploits pre-computed \ndistances to reduce the number  of distance computations \nat query time. In comparison w ith VP-tree, the fanout of \nMVP-tree is increased, and the height is reduced. \nMVP-tree outperforms VP-tree, but, as the same as \nVP-tree, MVP-tree is built from top to bottom. The top-down index construction strategy implies that the \nindex is static, and cannot be dynamically updated \naccording to database changes.  The cost of reconstructing \nthe whole index frequently becomes unacceptable for the \ndatabase that may possibly change frequently. \nUnlike VP-tree and MVP-tree, M-tree is a paged and \nbalanced metric tree that is built from bottom to top, with \nnode promotion and split mechanisms. M-tree can handle \nreconstruct the tree dynamically with low costs. M-tree \ntakes the complexity of distance computation into \naccount, and is a very effi cient index. But M-tree\xe2\x80\x99s \nsubspaces overlap is considerab le large, which affects its \nperformance. \nPractically, data of multime dia databases are often in \nmetric spaces. But, almost a ll of spatial access methods \n(SAMs), e.g. R-tree and its vari ants, are not applicable to \nmultimedia database. They are valid only when the following conditions are satisfied: (1) indexed objects are \nrepresented as feature values in a multidimensional vector \nspace; (2) the similarity of two objects is measured by \nEuclidean distance. However, metric trees such as \nMVP-tree and M-tree circumvent these problems. \nTherefore, they have a higher practical value. \nBecause M-tree is one of the best among \nmetric-based indices, this paper proposes a new \nmetric-based index, called M\n+-tree. It improves the \nperformance of M-tree. First, like M-tree, M+-tree is a \ndynamical paged and balance tree. It inherits M-tree\xe2\x80\x99s \npromotion mechanism, triangle inequality and the branch \nand bound technique. Second, M+-tree fully utilizes the \nfiltering twice idea used in MVP-tree. Third, M+-tree \nadopts the similar ideas of key dimension and the key \ndimension shift used in TV-tree (K.-I. Lin,H. V . Jagadish, \nand C. Faloutsos. 1994) in a novel way, based on our '
b' 2observations: a) dimension can be ordered by their \nsignificance in a metric-space, and b) the active \ndimensions can be shift for enhancing the efficiency. The \nkey dimension and the shift of the key dimension  reduce \nthe distance computation significantly.  \nThe remainder of the paper is structured as follows. \nSection 2 gives the problem definition. Section 3 introduces M\n+-tree, containing its data structures, key \ntechniques and basic algorithms. Section 4 presents \nexperimental results and performance evaluations. Section 5 concludes this paper. \n2 Problem Definition \nA metric space, M, is defined as, M = (O, d), where O is the domain of feature values and d is the distance \nfunction with the following properties. \n1\xef\xbc\x8ed(O\nx, O y) = d(O y, O x)  \n2\xef\xbc\x8ed(O x, O y) > 0 (O x \xe2\x89\xa0 O y), d(O x, O x) = 0  \n3\xef\xbc\x8ed(O x,Oy) \xe2\x89\xa4 d(O x, O z) + d(O z, O y) \nwhere O x, O y and O z are objects in O. The \n(dis)similarity between objects can be measured based on the given distance function d. R-neighbor search and \nk-nearest neighbor search are two basic types of \nsimilarity queries, defined as follows. \n \nDefinition 2.1 (r-neighbor search) Given a query object \nq\xe2\x88\x88O and a non-negative query radius r, the \nr-neighbor search of q is to retrieve the objects o \nsatisfying the condition: o \xe2\x88\x88O and d(q, o) \xe2\x89\xa4 r. \n \nDefinition 2.2(k-nearest neighbor search)  Given a \nquery object q \xe2\x88\x88O and an integer k \xe2\x89\xa5 1, the k-NN \nquery is to retrieve k objects with the shortest \ndistance from q. \n \nIndexing a metric space aims to provide an efficient \nsupport for retrieving objects similar to a reference (query) object (r-neighbor search or k-nearest neighbor search). \n3 The M+-tree \nM+-tree is a dynamical paged and balance tree. It \ncombines binary MVP-tree an d M-tree but improves the \npartition of binary MVP-tree and the node structure of \nM-tree. In binary MVP-tree, a data space is partitioned \ninto four subspaces with tw o vantage points while in \nM+-tree the partition is done through one vantage point \nand a key dimension. Because there is no distance computation for partitioning data space by key dimension, \nM\n+-tree has fewer distance com putations than MVP-tree. \nThe main idea behind the key dimension is to make the fanout of tree larger by partitioning a subspace further \ninto two subspaces, called twin-nodes. We can double the \nfiltering effectiveness by  utilizing the twin-nodes.\n \n3.1 The Key Dimension \n3.1.1 Method of Key Dimension Selection \nThe key dimension is a dimension that affects mostly \ndistance computation. Generally speaking, different data \ndistribution of dimensions has different effect on the \ndistance computation. A key dimension can be used to minimize the overlap, and thus avoid much too unnecessary paths traversal. \nIn SS-tree and SR-tree, the most optimal partition \nmethod is to partition the data space along the axis that \nhas maximal variance, which has been proved to be efficient for their index methods. It keeps the \noptimization of data space partition and reduces the \nnumber of paths traversed. So, in M\n+-tree, the dimension \nhaving maximal variance is selected to serve as the key \none. \n3.1.2 The Validity of Key Dimension Filtration \nIt is a simple process to use the key Dimension to filter. However, some inactive sub-trees may not be filtered. \nBut it always keeps all correct results. The correctness can be deduced from the following formula. \n Let O\ni(d1,d2,\xe2\x80\xa6d n) and O j(D1,D2,\xe2\x80\xa6D n) be two data \nobjects. The distance betw een the two objects is \nrepresented as follows:  \n  2 2\n2 22\n1 1 ) ( ) () (),(n n j i Dd Dd Dd OOD \xe2\x88\x92++\xe2\x88\x92+\xe2\x88\x92= L  \nLet k be the key dimension number and search radius \nbe r, then |d k-Dk|\xe2\x89\xa4D(O i,Oj). If D(O i,Oj)\xe2\x89\xa4r, then |d k-Dk|\xe2\x89\xa4\nr. So the active data cannot be filtered. \n3.2 Partition of Space \nSpace partition is one of the mo st important issues in the \nmetric indexes. M-tree partitions object space according \nto their relative distances. It grows in a bottom-up fashion. \nBy allocating a new node, the overflow of node is managed. At the same level of this node, the entries are \npartitioned between these two nodes. To reference the two \nnodes, two reference objects are promoted. In M-tree, partitioning by m-RAD-2 is best among all the partition \nmethods. \n Figure 1 (3) and (4) give the process of partitioning \nspace in M\n+-tree. A space corresponding to an entry in a \ntree node consists of two twin spaces, e.g., A and B. The \nnodes corresponding to twin spaces in M+-tree are called \ntwin nodes. These two sub-spaces are expressed through two boundary values of a key dimension, i.e. the maximal \nkey dimension value of the left twin space and the Figure 1: Partition in M-tree  v.s.  Partition in M+-tree1\n2 \nA      B  3\nA\xe2\x80\x99        B\xe2\x80\x99\nc   d e  f 4'
