b'The K-D-B-Tree: A Search Structure for \nLarge Multidimensibnal Dynamic Indexes \nJohn T. Robinson \nDepartment of Computer Science \nCarnegie-Mellon University \nPittsburgh, Pennsylvania 15213 \nAbstract - The problem of retrieving multikey records via \nrange queries from a large;dynamic index is considered. By \nlarge it is meant that most of the index must be stored on \nsecondary memory. By dynamic it is meant that insertions \nand deletions are intermixed with queries, so that the index \ncannot be built beforehand. A new data structure, the K-D-B- \ntree, is presented as a solution to this problem. K-D-B-trees \ncombine properties of K-D-trees and B-trees. It is expected \nthat the multidimensional search effieciency of balanced K-D- \ntrees and the I/O efficiency of B-trees should both be \napproximated in the K-D-B-tree. Preliminary experimental \nresults that tend to support this are reported. \n1. Int reduction \nConsider the following problem: \n1. There are index records of the form \nkey*, key,, . . . . key,-,, location, \nwhere keyi is an element of a finite totally \nordered set domaini, K is a constant, and \nThis research is supported in part by the National Science \nFoundation under Grant MCS 78-236-76 and the Office of \nNaval Research under Contract N00014-76-C-0370. \nPermission to copy without fee all or part of this material is granted \nprovided that the copies are not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the title of the \npublication and its date appear, and notice is given that copying is by \npermission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. \n%981 ACM 0-89791-040-O /80/0400/0010 $00.75 location gives the location of a database record \nwith these keys. \n2. It is desired to retrieve records based on queries \nof the form \nmini 5 keyi 5 maxi, OSi<K-1, \ni.e., range queries. \n3. Insertions and deletions of records are randomly \nintermixed with queries, implying that whatever \ndata structure is used to implement the index \nmust be built and maintained dynamically. \n4. The number of records in the index is so large \nthat it is necessary to store most of the index on \nsecondary memory (disk or drum) while it is \nbeing used, due to limitations on the size of \nprimary memory. \nIn the case that K = 1, the most efficient solution to this \nproblem is probably the B-tree (see [Bayer and McCreight \n721) or one of its variants (see [Comer 791 for a survey). In \nthe case that (4) is omitted, or alternatively, (3) is omitted so \nthat the data structure can be built statically and then \nmapped onto pages (see [Bentley 791 for an example), there \nare a number of solutions (see [Bentley and Friedman 791 for \na survey), such as the K-D-tree (see [Bentley 751). Also, it \nshould be mentioned that static solutions can often be \nconverted to pseudo-dynamic solutions by various techniques, \nsuch as using overflow areas for inserted records and \nmarking deleted records. In such cases, however, periodic \nreorganization of the index will usually be necessary to \nmaintain efficiency. \n10 \n'
b'Here, a new data structure, the K-D-a-tree, is presented as a \nsolution to the above problem. K-D-B-trees, like B-trees, are \nmultiway trees with fixed&e nodes that are always totally \nbalanced in the sense that the number of nodes accessed on \na path from the root node to a leaf node is the same for all \nleaf nodes. Each node is stored as a page so that efficient \nuse can be made of secondary memory with paging. Unlike \nB-trees, 50% utilization of pages cannot be guaranteed, \nalthough it is expected that in practice the number of pages \nless than half full should be small (as compared to the total \nnumber of pages). Preliminary experimental results support \nthis: as \xe2\x80\x9crandom\xe2\x80\x9d records are inserted, storage utilization \nseems to stay around 60% for cyclic P-D-B-trees and 3-D-B- \ntrees (see Section 4 for the definition of cyclic, and Section 6 \nfor details of the experiments). These percentages can \nhopefully be increased if reorganization techniques discussed \nin Section 5 are used (none of these tehcniques are currently \nimplemented). \nK-D-B-trees partition search spaces (subsets of domain0 x \ndomain, x . . . x domain& in a manner similar to K-D-trees: a \nsearch space is partitioned into two subspaces based on \ncomparison with some element of a single domain. Like K-D- \ntrees, various strategies can be used to select the domain and \nthe element in the domain. Some of these are discussed in \nSection 4. \nIn the next section the K-D-B-tree structure is defined. \nAlgorithms for queries, insertions, and deletions are presented \nin Sections 3, 4, and 5, respectively. Also discussed in \nSection 5 are reorganization techniques, analagous to \ncatenations and underflows in B-tree algorithms. The \ncombination of B-tree properties and K-D-tree properties in \nthe K-D-E-tree leads one to expect that the I/O efficiency of \nB-trees and the multidimensional search efficiency of K-D- \ntrees might both be approximated in K-D-B-trees. Some \npreliminary experimental results that tend to support this are \nreported in Section 6. Section 7 contains conclusions and a \ndiscussion of further research. 2. The K-D-B-Tree Structure \nOefine a point to be an element of domain0 x domain, x . . . x \ndomam,,, and a region to be the set of all points \n(xo, x,, . . . . xK.J satisfying \nmini < xi < maxi, O<i <K-l, \nfor some collection of mini, maxi E domaini. Points can be \nrepresented most simply by storing the xi, and regions by \nstoring the min, and maxi \nBelow, it will be required that certain regions be disjoint, and \nthat their union be a region -- thus the strict inequality on the \nright hand side of the region definition above. However, it will \nalso be required that the union of certain regions be all of \ndomain0 x domain, x . . . x domeinK-,. It is therefore \nnecessary t@ create for each domain a special element oOi, \nwhich is greater than all elements of domain,, and to allow the \nmaxi to assume these values. It is also convenient to \ndefine -oOi as the minimum of domaini \nLike B-trees, K-D-B-trees consist of a collection of pages and \na variable root 10 that gives the page ID of the root page. \nThere are two types of pages in a K-D-B-tree. \n1. Region pages: region pages contain a collection \nof (region, page ID) pairs. \n2. Point pages: point pages contain a collection of \n(point, location) pairs, where location gives the \nlocation of a database record. The \n(point, location) pair is in fact an index record. \nThe following set of properties define the K-D-B-tree \nstructure. The algorithm for range queries given in the next \nsection depends only on these properties, and the algorithms \nfor insertions and deletions are designed so as to preserve \nthese -properties. \n1. Considering each page as a node and each page \nID in a region page as a node pointer,. the \nresulting graph structure is a multi-way tree with \nroot root ID. Furthermore, \xe2\x80\x98no region page \ncontains a null pointer, and no region page is \nempty (note that this, together with the fact that \npoint pages do not contain page IDS, means that \n11 '
