b'Tree Data Structures and Efficient Indexing Techniques for Big\nData Management: A Comprehensive Study\nDimitrios Samoladas\nDepartment of Computer Engineering\nand Informatics\nUniversity of Patras\nPatras, Rion, Greece\nsamoladas@ceid.upatras.grChristos Karras\nDepartment of Computer Engineering\nand Informatics\nUniversity of Patras\nPatras, Rion, Greece\nc.karras@ceid.upatras.grAristeidis Karras\nDepartment of Computer Engineering\nand Informatics\nUniversity of Patras\nPatras, Rion, Greece\nakarras@ceid.upatras.gr\nLeonidas Theodorakopoulos\nDepartment of Management Science\nand Technology\nUniversity of Patras\nPatras, Koukouli, Greece\ntheodleo@upatras.grSpyros Sioutas\nDepartment of Computer Engineering\nand Informatics\nUniversity of Patras\nPatras, Rion, Greece\nsioutas@ceid.upatras.gr\nABSTRACT\nIn the modern era where data is produced from multivariate sources,\nthere is an urge to handle such data in an efficient yet effective\nmanner. Therefore, applications that necessitate such capabilities\nshall make use of data structures and indexing mechanisms that\ncan perform fast index operations along with low complexity as\nper insertion, deletion, and search. In this work, we survey B+\nTree, QuadTree, kD Tree, R Tree, and others along with efficient\nindexing techniques for big data management in order to provide\na generic overview of the field to readers. Ultimately, we provide\nsome indexing experiments as per insert operations and response\ntimes.\nCCS CONCEPTS\n\xe2\x80\xa2Information systems \xe2\x86\x92Data structures .\nKEYWORDS\nData Structures, B+ Tree, kD Tree, QuadTree, Indexes, Big Data\nManagement\nACM Reference Format:\nDimitrios Samoladas, Christos Karras, Aristeidis Karras, Leonidas Theodor-\nakopoulos, and Spyros Sioutas. 2022. Tree Data Structures and Efficient\nIndexing Techniques for Big Data Management: A Comprehensive Study.\nIn26th Pan-Hellenic Conference on Informatics (PCI 2022), November 25\xe2\x80\x9327,\n2022, Athens, Greece. ACM, New York, NY, USA, 10 pages. https://doi.org/\n10.1145/3575879.3575977\nPermission to make digital or hard copies of all or part of this work for personal or\nclassroom use is granted without fee provided that copies are not made or distributed\nfor profit or commercial advantage and that copies bear this notice and the full citation\non the first page. Copyrights for components of this work owned by others than ACM\nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,\nto post on servers or to redistribute to lists, requires prior specific permission and/or a\nfee. Request permissions from permissions@acm.org.\nPCI 2022, November 25\xe2\x80\x9327, 2022, Athens, Greece\n\xc2\xa92022 Association for Computing Machinery.\nACM ISBN 978-1-4503-9854-1/22/11. . . $15.00\nhttps://doi.org/10.1145/3575879.35759771 INTRODUCTION\nIn the past decade, there has been a significant increase in the\namount of information and data that is being produced. As a result\nof this matter, there has been an increasing interest in developing\nhigh-performance systems that are able to provide responses to\nqueries across terabytes of data in a matter of seconds.\nFurthermore, efficient indexing and searching techniques are\ncurrently gaining a lot of attention and they should be considered\na priority for big data analysis. Such types of solutions have the\npotential to provide consumers with insightful information about\ntheir data. This can also be applied in economics [1, 34] as well as\nin query expansion schemes [ 21]. However, in order to successfully\nretrieve and manage such information in terms of index size and\nsearch time, optimization of indexing methods is necessary, which\nis a process that may be rather challenging to carry out.\nIn this work, we survey emerging tree data structures and we\npresent some index mechanisms along with the centralized and\ndistributed variants of specific trees. The next section provides an\nextensive overview of such data structures in detail.\n2 OVERVIEW\nIn this section, we will discuss about indexes and their utility in\nthe database world. The indexes that we will talk about are B+\nTree, QuadTree, kD Tree and we will also mention their distributed\nimplementations according to third-party works and experiments\non them.\nBut first, let us initiate with some basic concepts of indexes.\nIndexes are structures that arose out of the need to quickly look up\ninformation stored in databases. Conventionally, if we wanted to\nsearch for all records that belong to a range or generally satisfy a\ncriterion, we would have to access the records one by one and check\nif they meet the conditions. For a database with N items, this would\nrequireO(\xf0\x9d\x91\x81)time, which for the huge databases required today, as\nwe have seen due to Big Data, is prohibitive for any undertaking.\nTherefore, an index is any data structure that can improve search\ntime. To achieve this improvement it sacrifices space and extra\nwrites to storage to maintain its structure. There is a wide variety\n123\n'
b'PCI 2022, November 25\xe2\x80\x9327, 2022, Athens, Greece D. Samoladas, et al.\nof indexes that satisfy different needs of a wide variety of data, such\nas spatial, temporal, text, multidimensional data, etc. Choosing the\nright index for the task we want to perform is a major part of the\nwhole process since it can lead to time complexities for search from\nO(\xf0\x9d\x91\x99\xf0\x9d\x91\x9c\xf0\x9d\x91\x94\xf0\x9d\x91\x81)toO(1).\n2.1 B+ Tree\nB+Tree is a tree version of the B-tree and an extension of the\nbinary tree in essence. The primary distinction between B and B+\ntrees is that B+trees are leaf-oriented. Thus, rather than containing\nkey-value pairs, internal nodes only hold keys, whereas data is\nstored on the leaves. The node of a B+tree may contain up to \xf0\x9d\x91\x9b\nindices, but no less than [\xf0\x9d\x91\x9b/2]indices, and \xf0\x9d\x91\x9b\xe2\x88\x921 keys. The root is an\nexception because, regardless of \xf0\x9d\x91\x9b, it may have at least two children.\nThe keys of each node are sorted, and pointers are interpolated\nbetween them. In other words, if we have keys \xf0\x9d\x90\xbe1,\xf0\x9d\x90\xbe2...,\xf0\x9d\x90\xbe\xf0\x9d\x91\x9b\xe2\x88\x921and\nindices\xf0\x9d\x91\x831,\xf0\x9d\x91\x832,...,\xf0\x9d\x91\x83\xf0\x9d\x91\x9b, then the index in position \xf0\x9d\x90\xbccorresponds to\nchild nodes with keys less than \xf0\x9d\x90\xbe\xf0\x9d\x91\x96and higher than or equal to \xf0\x9d\x90\xbe\xf0\x9d\x91\x96\xe2\x88\x921.\nFigure 1 is an example of the structure that we have explained. To\nhold\xf0\x9d\x91\x81keys, the B+tree requiresO(\xf0\x9d\x91\x81)storage capacity.\nFigure 1: Representation of a \xf0\x9d\x90\xb5+tree with\xf0\x9d\x91\x9b=4.\nB+trees are balanced. That is, the distance of the root from\nany leaf is the same for all leaves. This property makes the B+\ntree reliable since any change occurring, the tree makes sure it is\nalways balanced which keeps its performance constant in insertions,\ndeletions and searches.\n2.1.1 Insert Operations. To insert a new element into the tree, we\nbegin at the root and compare the key to be inserted with the keys\nalready existing in the node. We choose the proper index based\non what the key belongs to. We repeat the same procedure in a\nrecursive manner till we reach the sheet. If the leaf has room for\nextra data (that is, there are less than \xf0\x9d\x91\x9b\xe2\x88\x921 keys), the new key is\nadded. If the sheet is full, tearing will occur.\nWhen splitting, a new leaf is created, half of the old leaf\xe2\x80\x99s keys are\ntransferred to it, and the smallest key of the new leaf is transferred\nto the parent. Despite the fact that the parent is already full, we have\nmerely separated once more by pushing up the middle key instead\nof the minor one. This procedure is repeated until a parent node\ndoes not need splitting. If we reach the root and further splitting is\nrequired, we generate a new root with a key and two pointers. The\ntemporal complexity of inserting a new key is O(\xf0\x9d\x91\x99\xf0\x9d\x91\x9c\xf0\x9d\x91\x94\xf0\x9d\x91\x8f\xf0\x9d\x91\x81), where\xf0\x9d\x91\x81\nis the number of keys in the tree and \xf0\x9d\x91\x8fis the capacity of the node\nin children.2.1.2 Range Search. For range search, B+trees are modified such\nthat their leaves are connected serially by pointers, similar to a\nlinked list. To locate the data that falls within the search range,\nwe begin with a straightforward search for the smallest key that\nfalls within the search range. This search is conducted by locating\nthe leaf that the left end of the search range corresponds to. Then,\nafter the keys have been sorted, we identify the first key that is\nlarger than the left end of the search range and proceed serially\nto the right, comparing each key to the right end of the search\nrange. Since the leaves are connected by pointers, we do not need\nto retrace to access the next leaf but may instead utilise the pointer\nit has. Range-based search has a complexity of O(\xf0\x9d\x91\x99\xf0\x9d\x91\x9c\xf0\x9d\x91\x94\xf0\x9d\x91\x8f\xf0\x9d\x91\x81+\xf0\x9d\x91\x9a), as\n\xf0\x9d\x91\x99\xf0\x9d\x91\x9c\xf0\x9d\x91\x94\xf0\x9d\x91\x8f\xf0\x9d\x91\x81 is required to locate the leftmost key and \xf0\x9d\x91\x9ais the number\nof keys retrieved.\n2.1.3 Distributed implementation of \xf0\x9d\x90\xb5+Tree index. Initially, we\nhave the creation of the tree. The tree as a whole will be stored in\nan HBase table where each row of it represents a node of the tree.\nThen, we have an arbitrary ROWKEY and as columns, we have\ninformation concerning the node such as the keys that show the\nfollowing nodes the range of keys covered by the specific node and\nin the case of the leaves the data values.\nUsing a MapReduce task, the index was created and stored in\nHBase. It receives the data of a dataset from the Mapper and turns it\ninto an appropriate key-value format. After the records have been\ncreated, they are passed to a custom partitioner in order to divide the\ndata uniformly throughout the reducers. The default MapReduce\nhash partitioner is thus not utilised. The uniform distribution of\ndata in the reducers is accomplished by constructing intervals or\nchunks, as they are referred to in the Partitioner, by subtracting the\nsmallest key from the biggest key in the dataset and dividing the\nresulting value by the number of reducers. The preceding result of\nthe operation returns the interval that determines the endpoints of\neach interval. When the records reach the partitioner, their key is\ndetermined and they are forwarded to the appropriate reducer.\nIn the reduction step, local \xf0\x9d\x90\xb5+trees are generated, which are\nsubsequently connected to form the global tree. There are two nodes\ninside the reducer, the current and the next. Each pair that enters\nthe reducer is added to the leaf that is currently being created. If the\nleaf is already full, a new leaf is produced and the entered pair is\nadded to it. The leaf is then inserted into a buffer. When the buffer\nis filled, the data (the newly produced HBase leaves) are written.\nA final function is responsible for constructing the remainder of\nthe tree from the already-made leaves. The function ends when\na node with fewer children than the tree\xe2\x80\x99s order is encountered.\nThis function constructs the tree by recursively using the process\noutlined for the leaves.\n2.2 QuadTree\nQuadTree [ 30] is a reasonably basic geographical data indexing\napproach. Each node in a QuadTree represents a box that covers a\nportion of the area being indexed, with the root node representing\nthe whole region. Each node is either a leaf, which includes one\nor more points in the space and no children, or an internal node,\nwhich has precisely four children, one for each quadrant resulting\nfrom splitting the space of the node by two vertical axes, as seen in\nFigure 2. The name of the tree is derived from the term quadrants.\n124'
